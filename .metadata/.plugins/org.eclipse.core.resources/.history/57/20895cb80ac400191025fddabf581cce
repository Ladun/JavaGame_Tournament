package com.ladun.tournamentserver;

import java.io.IOException;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;
import java.net.SocketException;
import java.net.UnknownHostException;
import java.util.ArrayList;

import com.ladun.tournamentserver.util.BinaryWritter;

public class Server {

	private final static byte[] PACKET_SERVER_HEADER = new byte[] { 0x41,0x41};
	private final static byte PACKET_VALUETYPE_CLIENTID = 0x10;
	
	private int port;
	private Thread listenThread;
	private Thread timeoutThread;
	private boolean listening = false;
	private DatagramSocket socket;
	
	private ArrayList<Client> clients = new ArrayList<Client>();
	private int clientID = 1000;
	

	private final int MAX_PACKET_SIZE = 1024;
	private byte[] receiveDataBuffer = new byte[MAX_PACKET_SIZE * 10];
	
	private BinaryWritter bw = new BinaryWritter();
	
	private long stTime;
	
	private boolean packingCatching = false;
	private byte packetCatchType = 0x00;

	private boolean gaming;
	
	private int[] teamPoint = new int[8];
	
	
	
	public Server(int port) {
		this.port = port;
	}
	
	public void start() {
		try {
			socket = new DatagramSocket(port);
		} catch (SocketException e) {
			e.printStackTrace();
			return;
		}
		//System.out.println("--Start--------");
		
		
		listening = true;
		
		listenThread = new Thread(() -> listen(), "Server-ListenThread");		
		listenThread.start();
		/*
		timeoutThread = new Thread(new Timeout(this));
		timeoutThread.start();*/
		
		
		stTime = System.currentTimeMillis();
	}

	private void listen() {
		while(listening) {
			DatagramPacket packet = new DatagramPacket(receiveDataBuffer, MAX_PACKET_SIZE);
			try {
				socket.receive(packet);
			} catch (IOException e) {
				e.printStackTrace();				
			} 
			process(packet);
		}
	}
	
	
	private synchronized void process(DatagramPacket packet) {
		byte[] data = packet.getData();
		InetAddress address = packet.getAddress();
		int port= packet.getPort();
		
		if(packingCatching)
			dumpPacket(packet);
		
		if(data[0] == 0x40 && data[1] == 0x40) {
			String[] messages = new String(data,0,packet.getLength()).split(":");
			int _clientID = 0;
			
			switch(data[2]) {
			// Connection-----------------------------------------------------------
			// Client -> Server Packet : [header type]
			case 0x01 : {

				StringBuilder sb = new StringBuilder();
				bw.clear();
				
				if(gaming) {
					
					//TODO : 게임이 진행 중이여서 접속을 못한다는 패킷 전달
					bw.write((byte)0x07);
					sb.append(":");
					sb.append((char)0x00);
					bw.write((sb.toString()).getBytes());
					send(bw.getBytes(),address,port);
					return;
				}
				
				clients.add(new Client(address,port,clientID));

				bw.write((byte)0x03); //0x03 Value_Change -> 값 변경, clientID를 변경함
				sb.append(":");
				sb.append(clientID);
				sb.append(":");
				bw.write((sb.toString()).getBytes()); // ㅁㅁㅁ:clientID:clientID
				bw.write(PACKET_VALUETYPE_CLIENTID);
				send(bw.getBytes(),address,port);
				
				System.out.printf("[%s:%d] ID: %d Connect\n",address.getHostAddress() , port, clientID );			
				clientID++;
				break;
			}
			// Disconnection--------------------------------------------------------
			// Client -> Server Packet : [header type: clientID]
			case 0x02:	
				try {
					_clientID =Integer.parseInt(messages[1].trim());
					
				} catch (NumberFormatException e) {
					return;	
				}

				if(_clientID < 1000 || !isClientExist(_clientID))
					return;	
				
				if(gaming) {
					StringBuilder sb = new StringBuilder();
					bw.write((byte)0x07);
					sb.append(":");
					sb.append((char)0x01);
					sb.append(",");
					sb.append(_clientID);
					bw.write((sb.toString()).getBytes());
					sendToAllClients(bw.getBytes(),_clientID);
				}
				
				for(int i = 0 ; i < clients.size(); i++) {
					if(clients.get(i).getClientdID() == _clientID) {
						clients.remove(i);
						break;
					}
				}
				clientDisconnect(_clientID);

				System.out.printf("[%s:%d] ID: %d Disconnect\n",address.getHostAddress() , port, _clientID );		
				
				break;
			// Value Change--------------------------------------------------------
			// Client -> Server Packet : [header type: clientID : ValueType, value,....]
			case 0x03:{
				if(messages.length < 3)
					break;
				String[] netArgs = messages[2].split(",");
				// re-send --------------------------------------------------
				try {
					_clientID =Integer.parseInt(messages[1].trim());
					
				} catch (NumberFormatException e) {
					return;	
				}

				if(_clientID < 1000 || !isClientExist(_clientID))
					return;	

				StringBuilder sb = new StringBuilder();
				bw.clear();
				bw.write((byte)0x03);
				sb.append(":");
				sb.append(_clientID);
				sb.append(":");
				sb.append(messages[2]);
				bw.write((sb.toString()).getBytes());			
				
				
				
				sendToAllClients(bw.getBytes(), _clientID); 
				//--------------------------------------------------
				
				switch(netArgs[0].toCharArray()[0]) {
				case 0x11:
				case 0x12:
				case 0x13:
				case 0x18:
					// 0x11 : ValueType, x, y, z, angle
					// 0x12 : ValueType, angle
					// 0x13 : ValueType, type	
					// 0x18 : ValueType, hiding		
					break;
				case 0x14:{
					// ValueType, teamNumber
					Client c = getClient(_clientID);
					c.setTeamNumber(Byte.parseByte(netArgs[1]));
					break;
				}
				case 0x15:{
					// ValueType, health, changeType
					// changeType : 체력이 바뀐 타입 0 == init, 1 == hit
					// 
					Client c = getClient(_clientID);
					c.setHealth(Integer.parseInt(netArgs[1]));	

					if(c.getHealth() <= 0) {
						
						int[] alivePopulation = new int[8];
						
						for(Client _c : clients) {
							if(_c.getHealth() > 0) {
								alivePopulation[_c.getTeamNumber()]++;
							}
						}
						int aliveTeamIndex = -1;
						boolean flag = false;
						for(int i = 0; i < 8; i ++) {
							if(alivePopulation[i] > 0) {
								if(aliveTeamIndex != -1) {
									flag = false;
									break;
								}
								flag = true;
								aliveTeamIndex = i;
							}
						}
						if(flag){

							teamPoint[aliveTeamIndex]++;
							
							sb.setLength(0);
							bw.clear();
							bw.write((byte)0x06);
							sb.append(":");
							sb.append((char)0x04);
							sb.append(",");
							sb.append(aliveTeamIndex);
							bw.write((sb.toString()).getBytes());			
							
							sendToAllClients(bw.getBytes());
						}
						
					}
					
					break;
				}
				case 0x16:{
					// ValueType, currentMapIndex
					Client c = getClient(_clientID);
					int _currentMapIndex = Integer.parseInt(netArgs[1]);
					c.setCurrentMapIndex(_currentMapIndex);
					
					//System.out.println(_clientID);
					
					if(_currentMapIndex == c.getTargetMapIndex() && c.getTargetMapIndex() >= 2) {
						boolean allSame = true;
						for(Client _c : clients) {
							if(_c.getClientdID() != c.getClientdID()) {
								if(_c.getCurrentMapIndex() != c.getTargetMapIndex()) {
									allSame = false;
									break;
								}
							}
						}
						if(allSame) {
	
							sb.setLength(0);
							bw.clear();
							bw.write((byte)0x06);
							sb.append(":");
							sb.append((char)0x03);
							bw.write((sb.toString()).getBytes());	
							sendToAllClients(bw.getBytes());
						}
					}
					break;
				}
				case 0x17:{
					// ValueType, targetMapIndex
					Client c = getClient(_clientID);
					c.setTargetMapIndex(Integer.parseInt(netArgs[1]));
					
					//dumpPacket(packet);
					if(clients.size() == 1)
						break;
					
					boolean allSame= true;
					for(Client _c :clients) {
						if(_c.getClientdID() != _clientID) {
							if(c.getTargetMapIndex() != _c.getTargetMapIndex()) {
								allSame = false;
								break;
							}
						}
					}
					sb.setLength(0);
					bw.clear();
					bw.write((byte)0x06);
					sb.append(":");
					sb.append((char)0x00);
					sb.append(",");
					if(allSame) {
						sb.append(1);
						gaming = true;
					}
					else {		
						sb.append(0);	
						gaming = false;		
					}


					bw.write((sb.toString()).getBytes());					
					sendToAllClients(bw.getBytes());	
				}
				}
				
				break;
			}
			// Object Spawn--------------------------------------------------------
			// Client -> Server Packet : [header type: clientID (: objectName,parameter,.....)]
			case 0x04:{

				if(messages.length < 2)
					break;

				StringBuilder sb = new StringBuilder();
				if(messages.length == 2) {		// Player Spawn		
					try {
						_clientID =Integer.parseInt(messages[1].trim());
						
					} catch (NumberFormatException e) {
						return;	
					}

					if(_clientID < 1000 || !isClientExist(_clientID))
						return;	
					
					bw.clear();
					bw.write((byte)0x01);
					sb.append(":");
					sb.append(_clientID);
					bw.write((sb.toString()).getBytes());
					// 현재 새로운 플레이어가 스폰 되었다고 접속중인 client에게 정보를 보냄
					sendToAllClients(bw.getBytes(), _clientID); 
					
					//현재 새로 접속한 플레이어에게 기존의 플레이어들의 정보를 뿌림
					for(Client _c : clients) {
						if(_c.getClientdID() != _clientID)
						{
							sb.setLength(0);
							bw.clear();
							bw.write((byte)0x01);
							sb.append(":");
							sb.append(_c.getClientdID());
							bw.write((sb.toString()).getBytes());
							send(bw.getBytes(),address,port);
						}
					}
				}
				else {
					_clientID = Integer.parseInt(messages[1].trim());

					if(_clientID < 1000 || !isClientExist(_clientID))
						break;	

					bw.clear();
					bw.write((byte)0x04);
					sb.append(":");
					sb.append(messages[1]);
					sb.append(":");
					sb.append(messages[2]);
					bw.write((sb.toString()).getBytes());
					
					
					sendToAllClients(bw.getBytes(),_clientID);
				}
				
				break;
			}
			// Timeout Packet--------------------------------------------------------
			// Client -> Server Packet : [header type:clientID]
			case 0x05:

				if(messages.length < 2)
					break;
				try {
					_clientID =Integer.parseInt(messages[1].trim());
					
				} catch (NumberFormatException e) {
					return;	
				}

				if(_clientID < 1000 || !isClientExist(_clientID))
					return;	
				
				for(Client c : clients) {
					if(c.getClientdID() == _clientID) {
						c.setResponed(true);
						break;
					}
				}
				
				break;
			// Game State Packet--------------------------------------------------------
			// Client -> Server Packet : [header type:clientID: GameState, parameter.........]
			// GameState : 0 = allClientReady 	
			case 0x06:{

				StringBuilder sb = new StringBuilder();
				String[] netArgs = messages[2].split(",");
				switch(netArgs[0].toCharArray()[0]) {
				case 0x00:{				

					
					sb.setLength(0);
					bw.clear();
					bw.write((byte)0x06);
					sb.append(":");
					sb.append((char)0x01);
					bw.write((sb.toString()).getBytes());			
					
					send(bw.getBytes(), address, port);
					break;
				}
				case 0x01:{
					_clientID =Integer.parseInt(messages[1].trim());

					if(_clientID < 1000 || !isClientExist(_clientID))
						return;	
					sb.setLength(0);
					bw.clear();
					bw.write((byte)0x06);
					sb.append(":");
					sb.append((char)0x02);
					sb.append(",");
					sb.append(getClient(_clientID).getTargetMapIndex());
					bw.write((sb.toString()).getBytes());						

					send(bw.getBytes(), address, port);				
					
				}
				
				
				}
				
				break;
			}
			}
		}
		
	}
	
	public void send(byte[] _data, InetAddress address, int port) {
		assert(socket.isConnected());
		bw.clear();
		bw.write(PACKET_SERVER_HEADER);
		bw.write(_data);

		byte[] data = bw.getBytes();
		DatagramPacket packet = new DatagramPacket(data, data.length, address, port);
		
		try {
			socket.send(packet);
		} catch (IOException e) {
			e.printStackTrace();
		}
	}	
	/*
	 * 임시 해결법
	 * 자기자신에게 패킷을 보내서 receive를 멈추게 함 
	 */
	public void stopServer() {
		this.listening = false;
		
		try {
			send("stop".getBytes(),InetAddress.getByName("localhost"),port);
		} catch (UnknownHostException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		socket.close();
	}
	
	//--------------------------------------------------------------------------
	
	// Send to all clients
	public void sendToAllClients(byte[] data) {
		for(Client c : clients) {
			send(data,c.getAddress(),c.getPort());
		}
	}
	
	
	// Send to all clients except clients with the same clientID
	public void sendToAllClients(byte[] data,int clientID) {
		for(Client c : clients) {
			if(c.getClientdID() == clientID)
				continue;
			
			send(data,c.getAddress(),c.getPort());
		}
	}
	
	public void clientDisconnect(int _clientID) {

		StringBuilder sb = new StringBuilder();
		bw.clear();
		bw.write((byte)0x02);
		sb.append(":");
		sb.append(_clientID);
		bw.write((sb.toString()).getBytes());
		
		sendToAllClients(bw.getBytes());
	}
	
	private void dumpPacket(DatagramPacket packet) {
		byte[] data = packet.getData();
		InetAddress address = packet.getAddress();
		int port= packet.getPort();

		if(packetCatchType != 0x00) 
			if(packetCatchType != data[2])
				return;
		
		System.out.println("-----------------------------------------------");
		System.out.printf("PACKET: %d\n",(System.currentTimeMillis() -stTime)/1000);
		System.out.printf("\t%s:%d\n" , address.getHostAddress(), port);
		System.out.println("\tConetents:");
		System.out.print("\t\t");
		for(int i = 0 ; i < packet.getLength(); i++) {
			System.out.printf("%4x",data[i]);
			if((i +1) % 8 == 0) {
				System.out.print("\n\t\t");
			}
		}
		System.out.printf("\n\t\t%s\n",new String(data,0,packet.getLength()));
		System.out.println();
		System.out.println("-----------------------------------------------");
		
	}
	//--------------------------------------------------------------------------
	public boolean isClientExist(int _clientID) {
		for(Client c : clients) {
			if(c.getClientdID() == _clientID)
				return true;
		}
		return false;
	}
	
	public boolean isListening() {
		return listening;
	}

	public ArrayList<Client> getClients() {
		return clients;
	}
	
	public Client getClient(int _clientID) {
		for(Client c : clients) {
			if(c.getClientdID() == _clientID) {
				return c;
			}
		}
		return null;
	}

	public boolean isPackingCatching() {
		return packingCatching;
	}

	public void setPackingCatching(boolean packingCatching) {
		this.packingCatching = packingCatching;
	}

	public void setPacketCatchType(byte packetCatchType) {
		this.packetCatchType = packetCatchType;
	}
	
	
	
	
}
